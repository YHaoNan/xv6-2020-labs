# Memory Allocator
太简单了不写了

# Buffer cache (hard)
如果多个进程密集的使用文件系统，它们将在`bcache.lock`上竞争，这把锁在`kernel/bio.c`中，保护了磁盘快的缓存。`bcachetest`创建了多个进程，为了产生`bcache.lock`伤的竞争，它们重复的读取不同的文件。

如果你查看`kernel/bio.c`中的代码，你会看到`bcache.lock`保护了缓存的块缓冲链表、每一个块缓冲的引用计数（`b->refcnt`）以及缓存块的身份（`b->dev`和`b->blockno`）。

`kernel/bio.c`使用了一把大内核锁来维护lru链表的正确性，但这会造成过多的锁竞争：
```c
static struct buf*
bget(uint dev, uint blockno)
{
  struct buf *b;

  acquire(&bcache.lock);

  // Is the block already cached?
  for(b = bcache.head.next; b != &bcache.head; b = b->next){
    if(b->dev == dev && b->blockno == blockno){
      b->refcnt++;
      release(&bcache.lock);
      acquiresleep(&b->lock);
      return b;
    }
  }

  // Not cached.
  // Recycle the least recently used (LRU) unused buffer.
  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
    if(b->refcnt == 0) {
      b->dev = dev;
      b->blockno = blockno;
      b->valid = 0;
      b->refcnt = 1;
      release(&bcache.lock);
      acquiresleep(&b->lock);
      return b;
    }
  }
  panic("bget: no buffers");
}
```

主要的问题是为了找出一个能用的buf，其它无关的buf的操作也得等待，我们可以用一个hash表进一步分散竞争。

需要注意的就是死锁问题，有个坑，就是给一个buf转移hash桶到时候，需要两个桶都上锁，此时维护一个一致的上锁顺序就行，我这里是优先上下标较小的桶。